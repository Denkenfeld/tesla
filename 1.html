<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<title>NEON INVADERS</title>
<style>
* { margin:0; padding:0; box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
html, body {
  background:#000;
  width:100%; height:100%;
  overflow:hidden;
  touch-action:none;
  user-select:none;
  -webkit-user-select:none;
}
body {
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
}
#wrap {
  position:relative;
  width:100%;
  height:100%;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
}
canvas {
  display:block;
  max-width:100%;
  max-height:75vh;
  cursor:none;
}
/* ── TOUCH CONTROLS ─────────────────────────────────── */
#hud-touch {
  position:relative;
  width:100%;
  max-width:900px;
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding:10px 20px 6px;
  flex-shrink:0;
}
.dpad {
  display:flex;
  gap:12px;
}
.ctrl {
  display:flex;
  align-items:center;
  justify-content:center;
  border-radius:12px;
  border:2px solid;
  font-family:'Courier New',monospace;
  font-weight:bold;
  cursor:pointer;
  touch-action:none;
  transition:filter 0.08s, transform 0.08s;
  -webkit-tap-highlight-color:transparent;
}
.ctrl:active, .ctrl.pressed {
  filter:brightness(1.6);
  transform:scale(0.93);
}
.btn-left, .btn-right {
  width:90px; height:64px;
  font-size:28px;
  color:#00ffff;
  border-color:#00ffff;
  background:rgba(0,255,255,0.07);
  box-shadow:0 0 14px #00ffff88, inset 0 0 10px #00ffff22;
}
.btn-fire {
  width:140px; height:64px;
  font-size:18px; letter-spacing:3px;
  color:#ff00ff;
  border-color:#ff00ff;
  background:rgba(255,0,255,0.09);
  box-shadow:0 0 18px #ff00ff99, inset 0 0 12px #ff00ff22;
}
.btn-action {
  width:220px; height:64px;
  font-size:15px; letter-spacing:2px;
  color:#ffff00;
  border-color:#ffff00;
  background:rgba(255,255,0,0.07);
  box-shadow:0 0 14px #ffff0088, inset 0 0 10px #ffff0022;
}
/* pulse animation for action button */
@keyframes neonPulse {
  0%,100% { box-shadow:0 0 14px #ffff0088, inset 0 0 10px #ffff0022; }
  50%     { box-shadow:0 0 28px #ffff00cc, inset 0 0 18px #ffff0044; }
}
.btn-action { animation: neonPulse 1.2s infinite; }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>
  <!-- touch control bar -->
  <div id="hud-touch">
    <div class="dpad">
      <div class="ctrl btn-left"  id="bL">◀</div>
      <div class="ctrl btn-right" id="bR">▶</div>
    </div>
    <div class="ctrl btn-action"  id="bA">START</div>
    <div class="ctrl btn-fire"    id="bF">FIRE</div>
  </div>
</div>

<script>
'use strict';
const C = document.getElementById('c');
const ctx = C.getContext('2d');
const W = 900, H = 620;
C.width = W; C.height = H;

// ══════════════════════════════════════════════════════
//  TOUCH INPUT BRIDGE
// ══════════════════════════════════════════════════════
const keys = {};

function bindBtn(id, keyCode) {
  const el = document.getElementById(id);
  function down(e) {
    e.preventDefault();
    keys[keyCode] = true;
    el.classList.add('pressed');
  }
  function up(e) {
    e.preventDefault();
    keys[keyCode] = false;
    el.classList.remove('pressed');
  }
  el.addEventListener('touchstart',  down, { passive:false });
  el.addEventListener('touchend',    up,   { passive:false });
  el.addEventListener('touchcancel', up,   { passive:false });
  el.addEventListener('mousedown',   down);
  el.addEventListener('mouseup',     up);
  el.addEventListener('mouseleave',  up);
}
bindBtn('bL', 'ArrowLeft');
bindBtn('bR', 'ArrowRight');
bindBtn('bF', 'Space');

// Action button (start / next level)
const bA = document.getElementById('bA');
function actionTap(e) {
  e.preventDefault();
  if (AC.state === 'suspended') AC.resume();
  if (state === 'start' || state === 'gameover') startGame();
  else if (state === 'levelup') nextLevel();
}
bA.addEventListener('touchstart', actionTap, { passive:false });
bA.addEventListener('mousedown',  actionTap);

// Update action button label based on game state
function syncActionBtn() {
  const labels = { start:'START', gameover:'RETRY', levelup:'NEXT WAVE', playing:'' };
  bA.textContent = labels[state] || '';
  bA.style.display = state === 'playing' ? 'none' : 'flex';
}

// Keyboard still works
document.addEventListener('keydown', e => {
  keys[e.code] = true;
  if (['Space','ArrowLeft','ArrowRight','ArrowUp'].includes(e.code)) e.preventDefault();
  if (e.code === 'Space' || e.code === 'Enter') {
    if (AC.state === 'suspended') AC.resume();
    if (state === 'start' || state === 'gameover') startGame();
    else if (state === 'levelup') nextLevel();
  }
});
document.addEventListener('keyup', e => { keys[e.code] = false; });

// ══════════════════════════════════════════════════════
//  AUDIO ENGINE
// ══════════════════════════════════════════════════════
const AC = new (window.AudioContext || window.webkitAudioContext)();

function tone(freq, type, dur, vol, f0, f1) {
  const o = AC.createOscillator(), g = AC.createGain();
  o.connect(g); g.connect(AC.destination);
  o.type = type || 'square';
  o.frequency.setValueAtTime(f0 || freq, AC.currentTime);
  if (f1) o.frequency.exponentialRampToValueAtTime(f1, AC.currentTime + dur);
  g.gain.setValueAtTime(vol || 0.25, AC.currentTime);
  g.gain.exponentialRampToValueAtTime(0.0001, AC.currentTime + dur);
  o.start(AC.currentTime); o.stop(AC.currentTime + dur + 0.01);
}
function noise(dur, vol, freq) {
  const buf = AC.createBuffer(1, AC.sampleRate * dur, AC.sampleRate);
  const d = buf.getChannelData(0);
  for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;
  const src = AC.createBufferSource();
  src.buffer = buf;
  const g = AC.createGain(), f = AC.createBiquadFilter();
  f.type = 'bandpass'; f.frequency.value = freq || 200;
  src.connect(f); f.connect(g); g.connect(AC.destination);
  g.gain.setValueAtTime(vol || 0.4, AC.currentTime);
  g.gain.exponentialRampToValueAtTime(0.0001, AC.currentTime + dur);
  src.start(); src.stop(AC.currentTime + dur + 0.01);
}
const SFX = {
  shoot:   () => tone(900,'square',0.07,0.18,900,400),
  hit:     () => { tone(300,'sawtooth',0.12,0.25,500,80); noise(0.1,0.35,300); },
  bigHit:  () => { tone(180,'sawtooth',0.35,0.4,350,60); noise(0.25,0.6,200); },
  ufoHit:  () => { tone(600,'sine',0.3,0.3,600,1200); noise(0.15,0.3,500); },
  march:   s  => tone([130,100,80,65][s%4],'square',0.055,0.12),
  levelUp: () => [523,659,784,1047].forEach((f,i) => setTimeout(()=>tone(f,'sine',0.25,0.28),i*110)),
  gameOver:() => [440,370,300,220,150].forEach((f,i) => setTimeout(()=>tone(f,'sawtooth',0.22,0.28),i*140)),
  ufoFly:  () => tone(440,'sine',0.4,0.15,400,800),
};

// ══════════════════════════════════════════════════════
//  CONSTANTS & PALETTE
// ══════════════════════════════════════════════════════
const NEON      = ['#ff00ff','#00ffff','#ff6600','#00ff88','#ff0055','#ffff00','#7700ff','#00aaff'];
const ROW_COLS  = ['#ff00ff','#ff0077','#ff6600','#ffff00','#00ff88'];
const ENEMY_ROWS = 5, ENEMY_COLS = 11;
const EW = 38, EH = 30;
const PBSPEED = 9, EBSPEED = 4;

// ══════════════════════════════════════════════════════
//  STATE
// ══════════════════════════════════════════════════════
let state = 'start', frame = 0;
let score = 0, hiScore = 0, lives = 3, level = 1;
let shakeAmt = 0;

// ══════════════════════════════════════════════════════
//  PARTICLES
// ══════════════════════════════════════════════════════
let particles = [];

function explode(x, y, col, n) {
  n = n || 28;
  for (let i = 0; i < n; i++) {
    const a = Math.PI*2*i/n + (Math.random()-0.5)*0.6;
    const sp = 1.5 + Math.random()*5.5;
    particles.push({ x,y, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp,
      life:1, decay:0.018+Math.random()*0.028, r:2+Math.random()*3, col, grav:false, tail:[] });
  }
  shakeAmt = Math.max(shakeAmt, 5);
}
function firework(x, y) {
  const c1 = NEON[Math.floor(Math.random()*NEON.length)];
  const c2 = NEON[Math.floor(Math.random()*NEON.length)];
  for (let i = 0; i < 70; i++) {
    const a = Math.random()*Math.PI*2, sp = 0.5+Math.random()*9;
    particles.push({ x,y, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp-1,
      life:1, decay:0.008+Math.random()*0.018, r:1.5+Math.random()*3.5,
      col: Math.random()<0.5?c1:c2, grav:true, tail:[] });
  }
}
function tickParticles() {
  for (let i = particles.length-1; i >= 0; i--) {
    const p = particles[i];
    p.tail.push({x:p.x,y:p.y});
    if (p.tail.length > 7) p.tail.shift();
    p.x += p.vx; p.y += p.vy;
    p.vx *= 0.97; p.vy *= 0.97;
    if (p.grav) p.vy += 0.1;
    p.life -= p.decay;
    if (p.life <= 0) particles.splice(i,1);
  }
}
function drawParticles() {
  ctx.save();
  for (const p of particles) {
    ctx.globalAlpha = p.life * 0.9;
    ctx.shadowBlur = 14; ctx.shadowColor = p.col;
    ctx.fillStyle = p.col;
    ctx.beginPath(); ctx.arc(p.x,p.y,p.r*p.life,0,Math.PI*2); ctx.fill();
    if (p.tail.length > 1) {
      ctx.strokeStyle = p.col; ctx.lineWidth = p.r*0.6*p.life; ctx.shadowBlur = 8;
      ctx.beginPath(); ctx.moveTo(p.tail[0].x,p.tail[0].y);
      for (const t of p.tail) ctx.lineTo(t.x,t.y); ctx.stroke();
    }
  }
  ctx.restore();
}

// ══════════════════════════════════════════════════════
//  STARS & GRID
// ══════════════════════════════════════════════════════
const stars = Array.from({length:130}, () => ({
  x:Math.random()*W, y:Math.random()*H,
  r:Math.random()*1.8, phase:Math.random()*Math.PI*2,
  col:NEON[Math.floor(Math.random()*NEON.length)]
}));
function drawStars() {
  for (const s of stars) {
    s.phase += 0.018;
    ctx.globalAlpha = 0.3 + 0.7*Math.abs(Math.sin(s.phase));
    ctx.shadowBlur=5; ctx.shadowColor=s.col; ctx.fillStyle=s.col;
    ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fill();
  }
  ctx.globalAlpha=1; ctx.shadowBlur=0;
}
function drawGrid() {
  ctx.save(); ctx.globalAlpha=0.04; ctx.strokeStyle='#0055aa'; ctx.lineWidth=1;
  for (let x=0;x<W;x+=50){ ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,H);ctx.stroke(); }
  for (let y=0;y<H;y+=50){ ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(W,y);ctx.stroke(); }
  ctx.restore();
}

// ══════════════════════════════════════════════════════
//  DRAW HELPERS
// ══════════════════════════════════════════════════════
function glow(col,b){ ctx.shadowBlur=b||18; ctx.shadowColor=col; }
function txt(t,x,y,col,sz,align){
  ctx.save(); glow(col,22); ctx.fillStyle=col;
  ctx.font=`bold ${sz||20}px 'Courier New',monospace`;
  ctx.textAlign=align||'left'; ctx.fillText(t,x,y); ctx.restore();
}
function line(x1,y1,x2,y2,col,lw){
  ctx.save(); glow(col,14); ctx.strokeStyle=col; ctx.lineWidth=lw||2;
  ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke(); ctx.restore();
}

// ══════════════════════════════════════════════════════
//  ENEMY DRAWING
// ══════════════════════════════════════════════════════
function drawEnemy(x,y,type,col,t) {
  const hw=EW/2, hh=EH/2, pulse=0.85+0.15*Math.sin(t*0.08+x*0.05);
  ctx.save(); ctx.translate(x,y); ctx.scale(pulse,pulse);
  glow(col,20); ctx.strokeStyle=col; ctx.fillStyle=col; ctx.lineWidth=2;
  if (type===0){
    ctx.beginPath(); ctx.arc(0,0,9,0,Math.PI*2); ctx.stroke();
    ctx.beginPath();
    for(let i=0;i<6;i++){const a=Math.PI*2*i/6+t*0.03;ctx.moveTo(Math.cos(a)*9,Math.sin(a)*9);ctx.lineTo(Math.cos(a)*15,Math.sin(a)*15);}
    ctx.stroke(); ctx.globalAlpha=0.5; ctx.beginPath(); ctx.arc(0,0,6,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
  } else if(type===1){
    ctx.beginPath(); ctx.moveTo(-hw+4,-hh+4);ctx.lineTo(hw-4,-hh+4);ctx.lineTo(hw-4,hh-4);ctx.lineTo(-hw+4,hh-4);ctx.closePath(); ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(-hw+4,-2);ctx.lineTo(-hw-4,-8);ctx.moveTo(-hw+4,2);ctx.lineTo(-hw-4,8);
    ctx.moveTo(hw-4,-2);ctx.lineTo(hw+4,-8);ctx.moveTo(hw-4,2);ctx.lineTo(hw+4,8); ctx.stroke();
    ctx.globalAlpha=0.4; ctx.fillRect(-9,-6,7,9); ctx.fillRect(2,-6,7,9); ctx.globalAlpha=1;
  } else if(type===2){
    ctx.beginPath(); ctx.moveTo(-14,-hh);ctx.lineTo(14,-hh);ctx.lineTo(14,4);ctx.lineTo(8,4);ctx.lineTo(8,hh);ctx.lineTo(-8,hh);ctx.lineTo(-8,4);ctx.lineTo(-14,4);ctx.closePath(); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(-14,-hh);ctx.lineTo(-hw,-hh-6);ctx.moveTo(14,-hh);ctx.lineTo(hw,-hh-6); ctx.stroke();
    ctx.globalAlpha=0.5; ctx.fillRect(-10,-5,7,8); ctx.fillRect(3,-5,7,8); ctx.globalAlpha=1;
  } else if(type===3){
    ctx.beginPath(); ctx.moveTo(0,-hh);ctx.lineTo(hw,0);ctx.lineTo(0,hh);ctx.lineTo(-hw,0);ctx.closePath(); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0,-hh+7);ctx.lineTo(hw-7,0);ctx.lineTo(0,hh-7);ctx.lineTo(-hw+7,0);ctx.closePath();
    ctx.globalAlpha=0.35; ctx.fill(); ctx.globalAlpha=1; ctx.stroke();
  } else {
    ctx.beginPath(); ctx.ellipse(0,0,hw-4,hh-4,0,0,Math.PI*2); ctx.stroke();
    ctx.beginPath();
    for(let i=0;i<5;i++){const a=Math.PI+(Math.PI/4)*i;ctx.moveTo(Math.cos(a)*(hw-4),Math.sin(a)*(hh-4));ctx.lineTo(Math.cos(a)*(hw+4),Math.sin(a)*(hh+4)+(i%2)*4);} ctx.stroke();
    ctx.globalAlpha=0.4; ctx.beginPath(); ctx.ellipse(0,-2,5,5,0,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
  }
  ctx.restore();
}

// ══════════════════════════════════════════════════════
//  PLAYER
// ══════════════════════════════════════════════════════
const PLR = {x:W/2,y:H-65,w:52,h:34,spd:6,alive:true,inv:0,cd:0};
const PLRCOL = '#00ffff';

function drawPlayer() {
  if (!PLR.alive) return;
  if (PLR.inv>0 && Math.floor(PLR.inv/6)%2===0) return;
  const {x,y,w,h}=PLR;
  ctx.save(); glow(PLRCOL,28); ctx.strokeStyle=PLRCOL; ctx.lineWidth=2.8;
  ctx.beginPath(); ctx.moveTo(x,y-h/2); ctx.lineTo(x+w/2,y+h/2); ctx.lineTo(x+w/4,y+h/4);
  ctx.lineTo(x-w/4,y+h/4); ctx.lineTo(x-w/2,y+h/2); ctx.closePath(); ctx.stroke();
  ctx.fillStyle=PLRCOL; ctx.globalAlpha=0.2; ctx.fill(); ctx.globalAlpha=1;
  ctx.beginPath(); ctx.moveTo(x,y-h/2-2); ctx.lineTo(x,y-h/2-10); ctx.lineWidth=4; ctx.stroke();
  const eg=ctx.createLinearGradient(x-10,y+h/2,x+10,y+h/2+10);
  eg.addColorStop(0,'transparent'); eg.addColorStop(0.5,PLRCOL); eg.addColorStop(1,'transparent');
  ctx.strokeStyle=eg; ctx.lineWidth=5;
  ctx.beginPath(); ctx.moveTo(x-9,y+h/2+5); ctx.lineTo(x+9,y+h/2+5); ctx.stroke();
  ctx.restore();
}

// ══════════════════════════════════════════════════════
//  ENEMIES
// ══════════════════════════════════════════════════════
let enemies=[], eDir=1, eMoveT=0, eStepIdx=0;
function initEnemies(){
  enemies=[];
  for(let r=0;r<ENEMY_ROWS;r++) for(let c=0;c<ENEMY_COLS;c++)
    enemies.push({row:r,col:c,x:90+c*70,y:70+r*55,alive:true,type:r,col:ROW_COLS[r]});
}
function tickEnemies(){
  const alive=enemies.filter(e=>e.alive);
  if(!alive.length) return;
  const interval=Math.max(4,58-level*4-Math.floor((ENEMY_ROWS*ENEMY_COLS-alive.length)*0.6));
  eMoveT++;
  if(eMoveT<interval) return;
  eMoveT=0; SFX.march(eStepIdx++);
  let hitWall=false;
  for(const e of alive){ e.x+=eDir*14; if(e.x>W-55||e.x<55) hitWall=true; }
  if(hitWall){ eDir*=-1; for(const e of alive) e.y+=20; }
  if(Math.random()<0.007+level*0.002){
    const byCols={};
    for(const e of alive) if(!byCols[e.col]||e.row>byCols[e.col].row) byCols[e.col]=e;
    const pool=Object.values(byCols), sh=pool[Math.floor(Math.random()*pool.length)];
    enemyBullets.push({x:sh.x,y:sh.y+EH/2,col:sh.col,active:true});
  }
}

// ══════════════════════════════════════════════════════
//  UFO
// ══════════════════════════════════════════════════════
let ufo=null, ufoT=0;
const UFOCOL='#ff00ff';
function tickUFO(){
  ufoT++;
  if(!ufo&&ufoT%550===0){ ufo={x:-60,y:40,alive:true}; SFX.ufoFly(); }
  if(!ufo) return;
  ufo.x+=3;
  if(ufo.x>W+70){ ufo=null; return; }
  for(let i=playerBullets.length-1;i>=0;i--){
    const b=playerBullets[i];
    if(Math.abs(b.x-ufo.x)<32&&Math.abs(b.y-ufo.y)<22){
      playerBullets.splice(i,1); score+=150+level*25;
      explode(ufo.x,ufo.y,UFOCOL,55); firework(ufo.x,ufo.y);
      SFX.ufoHit(); ufo=null; shakeAmt=10; return;
    }
  }
}
function drawUFO(){
  if(!ufo) return;
  const {x,y}=ufo;
  ctx.save(); glow(UFOCOL,28); ctx.strokeStyle=UFOCOL; ctx.lineWidth=2.5;
  ctx.beginPath(); ctx.ellipse(x,y+9,32,13,0,Math.PI,0); ctx.stroke();
  ctx.beginPath(); ctx.ellipse(x,y,20,12,0,0,Math.PI*2); ctx.stroke();
  ctx.fillStyle=UFOCOL; ctx.globalAlpha=0.6;
  [-14,0,14].forEach(ox=>{ctx.beginPath();ctx.arc(x+ox,y,3.5,0,Math.PI*2);ctx.fill();});
  ctx.globalAlpha=1; ctx.restore();
}

// ══════════════════════════════════════════════════════
//  SHIELDS
// ══════════════════════════════════════════════════════
let shields=[];
const SHCOL='#00ff88';
function initShields(){
  shields=[];
  const shape=[[0,1,1,1,1,1,1,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1],[1,1,0,0,0,0,1,1]];
  for(let i=0;i<4;i++){
    const sx=105+i*182, sy=H-128;
    const pixels=[];
    for(let r=0;r<shape.length;r++) for(let c=0;c<shape[r].length;c++)
      if(shape[r][c]) pixels.push({x:sx+c*10,y:sy+r*10,alive:true});
    shields.push(pixels);
  }
}
function drawShields(){
  ctx.save();
  for(const sh of shields) for(const p of sh){
    if(!p.alive) continue;
    glow(SHCOL,12); ctx.fillStyle=SHCOL; ctx.globalAlpha=0.8;
    ctx.fillRect(p.x,p.y,9,9);
  }
  ctx.globalAlpha=1; ctx.restore();
}

// ══════════════════════════════════════════════════════
//  BULLETS
// ══════════════════════════════════════════════════════
let playerBullets=[], enemyBullets=[];

function shootPlayer(){
  if(PLR.cd>0||!PLR.alive) return;
  if(playerBullets.filter(b=>b.active).length>=3) return;
  playerBullets.push({x:PLR.x,y:PLR.y-PLR.h/2-5,active:true});
  PLR.cd=14; SFX.shoot();
}
function shieldHit(bx,by){
  for(const sh of shields) for(const p of sh)
    if(p.alive&&bx>=p.x&&bx<=p.x+9&&by>=p.y&&by<=p.y+9){ p.alive=false; return true; }
  return false;
}
function tickBullets(){
  for(let i=playerBullets.length-1;i>=0;i--){
    const b=playerBullets[i];
    if(!b.active){playerBullets.splice(i,1);continue;}
    b.y-=PBSPEED;
    if(b.y<0){playerBullets.splice(i,1);continue;}
    let hit=false;
    for(const e of enemies){ if(!e.alive)continue; if(Math.abs(b.x-e.x)<EW/2&&Math.abs(b.y-e.y)<EH/2){ e.alive=false; score+=(ENEMY_ROWS-e.row)*10+level*5; explode(e.x,e.y,e.col,22+level*2); SFX.hit(); hit=true; break; } }
    if(!hit&&shieldHit(b.x,b.y)) hit=true;
    if(hit) playerBullets.splice(i,1);
  }
  for(let i=enemyBullets.length-1;i>=0;i--){
    const b=enemyBullets[i];
    if(!b.active){enemyBullets.splice(i,1);continue;}
    b.y+=EBSPEED+level*0.35;
    if(b.y>H+10){enemyBullets.splice(i,1);continue;}
    if(PLR.alive&&PLR.inv<=0&&Math.abs(b.x-PLR.x)<22&&Math.abs(b.y-PLR.y)<18){
      lives--; PLR.inv=130; explode(PLR.x,PLR.y,PLRCOL,45); SFX.bigHit(); shakeAmt=14;
      if(lives<=0){ PLR.alive=false; setTimeout(()=>{hiScore=Math.max(hiScore,score);state='gameover';SFX.gameOver();syncActionBtn();},1600); }
      enemyBullets.splice(i,1); continue;
    }
    if(shieldHit(b.x,b.y)) enemyBullets.splice(i,1);
  }
}
function drawBullets(){
  ctx.save();
  for(const b of playerBullets){
    if(!b.active)continue;
    glow('#ffffff',22); ctx.strokeStyle=PLRCOL; ctx.lineWidth=3.5;
    ctx.beginPath(); ctx.moveTo(b.x,b.y); ctx.lineTo(b.x,b.y+16); ctx.stroke();
    ctx.fillStyle='#ffffff'; ctx.globalAlpha=0.9; ctx.beginPath(); ctx.arc(b.x,b.y,3,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
  }
  for(const b of enemyBullets){
    if(!b.active)continue;
    const tt=frame*0.2; glow(b.col,18); ctx.strokeStyle=b.col; ctx.lineWidth=2.5;
    ctx.beginPath(); ctx.moveTo(b.x+Math.sin(tt)*3,b.y-8); ctx.lineTo(b.x-Math.sin(tt)*3,b.y); ctx.lineTo(b.x+Math.sin(tt+1)*3,b.y+8); ctx.stroke();
  }
  ctx.restore();
}

// ══════════════════════════════════════════════════════
//  HUD
// ══════════════════════════════════════════════════════
function drawHUD(){
  txt(`SCORE  ${score}`,18,30,'#00ffff',17);
  txt(`HI  ${hiScore}`,W/2,30,'#ffff00',17,'center');
  txt(`LEVEL  ${level}`,W-18,30,'#ff00ff',17,'right');
  for(let i=0;i<lives;i++){
    const lx=22+i*34, ly=H-14;
    ctx.save(); glow(PLRCOL,15); ctx.strokeStyle=PLRCOL; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(lx,ly-10);ctx.lineTo(lx+12,ly+4);ctx.lineTo(lx+6,ly+2);ctx.lineTo(lx-6,ly+2);ctx.lineTo(lx-12,ly+4);ctx.closePath(); ctx.stroke(); ctx.restore();
  }
  line(0,40,W,40,'#ff00ff',1.2);
  line(0,H-32,W,H-32,'#00ffff',1.2);
  if(ufo) txt('⬡ UFO +150',W-15,H-6,'#ff00ff',11,'right');
}

// ══════════════════════════════════════════════════════
//  SCANLINES / VIGNETTE
// ══════════════════════════════════════════════════════
function drawScanlines(){
  ctx.save(); ctx.globalAlpha=0.03; ctx.fillStyle='#000';
  for(let y=0;y<H;y+=3) ctx.fillRect(0,y,W,1.5);
  const vg=ctx.createRadialGradient(W/2,H/2,H*0.35,W/2,H/2,H*0.85);
  vg.addColorStop(0,'rgba(0,0,0,0)'); vg.addColorStop(1,'rgba(0,0,30,0.45)');
  ctx.fillStyle=vg; ctx.globalAlpha=1; ctx.fillRect(0,0,W,H);
  ctx.restore();
}

// ══════════════════════════════════════════════════════
//  SCREENS
// ══════════════════════════════════════════════════════
function drawStartScreen(){
  const hue=frame%360;
  ctx.save(); glow(`hsl(${hue},100%,60%)`,40); ctx.fillStyle=`hsl(${hue},100%,60%)`;
  ctx.font='bold 76px "Courier New",monospace'; ctx.textAlign='center';
  ctx.fillText('NEON',W/2,H/2-68); ctx.restore();
  ctx.save(); glow(`hsl(${(hue+140)%360},100%,60%)`,40); ctx.fillStyle=`hsl(${(hue+140)%360},100%,60%)`;
  ctx.font='bold 76px "Courier New",monospace'; ctx.textAlign='center';
  ctx.fillText('INVADERS',W/2,H/2+8); ctx.restore();
  if(Math.sin(frame*0.07)>0) txt('TAP  START  OR  PRESS  SPACE',W/2,H/2+66,'#ffffff',19,'center');
  txt('◀ ▶  MOVE        FIRE  BUTTON  SHOOTS',W/2,H/2+100,'#555',13,'center');
  const sample=[0,1,2,3,4];
  sample.forEach((t,i)=>drawEnemy(160+i*148,H/2+155,t,ROW_COLS[t],frame));
}
function drawLevelUpScreen(){
  txt(`WAVE  ${level}  CLEAR!`,W/2,H/2-55,'#ffff00',40,'center');
  txt(`ENTERING  WAVE  ${level+1}`,W/2,H/2+5,'#00ffff',26,'center');
  if(Math.sin(frame*0.12)>0) txt('TAP  NEXT WAVE  OR  SPACE',W/2,H/2+52,'#ff00ff',18,'center');
  if(frame%25===0) firework(50+Math.random()*(W-100),60+Math.random()*(H/2-60));
}
function drawGameOverScreen(){
  const col=Math.sin(frame*0.08)>0?'#ff0055':'#ff4400';
  txt('GAME  OVER',W/2,H/2-48,col,60,'center');
  txt(`SCORE:  ${score}`,W/2,H/2+18,'#ffff00',30,'center');
  if(score>=hiScore&&score>0) txt('✦  NEW HIGH SCORE  ✦',W/2,H/2+60,'#ff00ff',22,'center');
  if(Math.sin(frame*0.1)>0) txt('TAP  RETRY  OR  SPACE',W/2,H/2+100,'#00ffff',18,'center');
  if(frame%90===0) firework(60+Math.random()*(W-120),80+Math.random()*200);
}

// ══════════════════════════════════════════════════════
//  INIT / TRANSITIONS
// ══════════════════════════════════════════════════════
function startGame(){
  score=0;lives=3;level=1;
  PLR.x=W/2;PLR.alive=true;PLR.inv=0;PLR.cd=0;
  playerBullets=[];enemyBullets=[];particles=[];
  ufo=null;ufoT=0;eDir=1;eMoveT=0;
  initEnemies();initShields();
  state='playing'; syncActionBtn();
}
function nextLevel(){
  level++;
  PLR.x=W/2;PLR.alive=true;PLR.inv=0;PLR.cd=0;
  playerBullets=[];enemyBullets=[];particles=[];
  ufo=null;eDir=1;eMoveT=0;
  initEnemies();initShields();
  state='playing'; syncActionBtn();
}

// ══════════════════════════════════════════════════════
//  MAIN LOOP
// ══════════════════════════════════════════════════════
function loop(){
  requestAnimationFrame(loop);
  frame++;
  let sx=0,sy=0;
  if(shakeAmt>0){ sx=(Math.random()-0.5)*shakeAmt;sy=(Math.random()-0.5)*shakeAmt;shakeAmt*=0.85;if(shakeAmt<0.3)shakeAmt=0; }
  ctx.save(); ctx.translate(sx,sy);
  ctx.fillStyle='#050510'; ctx.fillRect(-20,-20,W+40,H+40);
  drawGrid(); drawStars();

  if(state==='playing'){
    if(PLR.alive){
      if(keys['ArrowLeft']||keys['KeyA']) PLR.x=Math.max(32,PLR.x-PLR.spd);
      if(keys['ArrowRight']||keys['KeyD']) PLR.x=Math.min(W-32,PLR.x+PLR.spd);
      if(keys['Space']||keys['ArrowUp']||keys['KeyZ']||keys['KeyX']) shootPlayer();
    }
    if(PLR.cd>0) PLR.cd--;
    if(PLR.inv>0) PLR.inv--;
    tickEnemies(); tickUFO(); tickBullets(); tickParticles();
    if(enemies.filter(e=>e.alive).length===0){ hiScore=Math.max(hiScore,score); SFX.levelUp(); state='levelup'; syncActionBtn(); }
    if(enemies.filter(e=>e.alive).some(e=>e.y>H-70)){
      lives=0;PLR.alive=false;
      for(let i=0;i<4;i++) explode(PLR.x,PLR.y,PLRCOL,30); shakeAmt=20;
      setTimeout(()=>{hiScore=Math.max(hiScore,score);state='gameover';SFX.gameOver();syncActionBtn();},1600);
    }
    drawShields(); enemies.forEach(e=>{if(e.alive)drawEnemy(e.x,e.y,e.type,e.col,frame);}); drawUFO(); drawBullets(); drawPlayer(); drawParticles(); drawHUD();
  }
  else if(state==='start'){ tickParticles();drawParticles();if(frame%70===0)firework(60+Math.random()*(W-120),60+Math.random()*180);drawStartScreen(); }
  else if(state==='levelup'){ drawShields();drawHUD();tickParticles();drawParticles();drawLevelUpScreen(); }
  else if(state==='gameover'){ tickParticles();drawParticles();drawGameOverScreen(); }

  drawScanlines();
  ctx.restore();
}

initEnemies(); initShields(); syncActionBtn(); loop();
</script>
</body>
</html>